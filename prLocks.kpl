<?xml version="1.0" encoding="UTF-8"?><pag xmlns="www.kepler.com.mx/2003/KSchema" roles="" tit="Hola">	<grp dim="1,-1,10,20" brdr="2,1" clr="0,0,0" bclr="213,210,210">		<br/><sp/><txt>Esta opci&#243;n ejemplifica el uso de locks</txt><br/><txt>N&#250;mero de ciclos</txt><br/>		<inp id="nTry" dim="10,1" brdr="2,1" bclr="255,255,255" type="number"/><br/><br/><txt>Instrucciones: Abrir 2 instancias de kepler, y preparar esta  pagina para ser ejecutada en ambos.</txt><br/><txt>Ejecutar ambos keplers, y lo que se busca es que cada kepler obtenga un n&#250;mero &#250;nico siempre.</txt><br/><br/><txt>Resultado esperado</txt><br/><txt>Al ejecutar sin mecanismo de lock, no es posible asegurar n&#250;meros unicos, hay al menos algunos n&#250;meros que se repiten (Condici&#243;n de carrera)</txt><br/><br/><txt>Al ejecutarse con el mecanismo de lock, no importa cu&#225;ntos ciclos se tome, nunca deber&#225;n repetirse los n&#250;meros en las diferentes instancias de kepler.</txt><br/>		<br/>		<bot id="bot" dim="20,0" brdr="5" text="Obtener N&#250;mero (Sin Lock)" OnEnter="ejecuta()"/><br/><br/>		<bot id="bot2" dim="20,0" brdr="5" text="Obtener N&#250;mero (CON Lock)" OnEnter="ejecuta(1)"/><br/><br/>		<inp id="texto" dim="20,30" brdr="2,1" bclr="255,255,255" type="string"/>	</grp>	<script>		InstallDriver("KDB75");		class Main {			var frn,kdb,sys;			var arch;//Nombre de Archivo que sirve como recurso compartido, y al que se desea asegurar acceso unico temporal			var nTry;//Número de intentos			var stream;			fun Main() {				frn=new FRNT;				kdb=new KDB;				sys=new SYS;				kdb.connect();				arch="_archivoContador.txt";				frn.set("nTry",200);			}						fun ejecuta(conLock){				nTry=frn.get("nTry");//Número de intentos				stream="";				for(var i=0;i<nTry;i++){					if (conLock){						ConLock();					}else{						SinLock();					}				}				frn.set("texto",stream);			}			fun SinLock(){				var ultimo=ObtenUltimo();				stream=stream & ultimo & "\#013";				Guarda(ultimo+1);				//frn.set("texto",stream);			}			fun ConLock(){//ESTA ES LA FUNCIÓN PRINCIPAL QUE ejemplifica uso compartido en MUTEX. Lo demás solo es para probar la funcionalidad.				var archFoliador="lockDocto";;//Nombre del archivo foliador que nos sirve como MUTEX. Todos los procesos con el mismo nombre de archivo comparten el lock				var bOk=0;				while(!bOk){//Mientras no obtenga el recurso compartido intentará en repetidas ocasiones.					kdb.iov("GET,"&archFoliador&",a1,$,datLock,$,1");//Lee una serie de campos en el servidor					kdb.exec();					var turno=kdb.get("datLock","a1");					if(turno==1){//SOLAMENTE si se dio el turno 1, quiere decir que tiene derecho a usar el recurso compartido						bOk=1;						//===========AQUÍ va el código que debe estar protegido por acceso único a recurso compartido						SinLock();//En este caso el código protegido es el mismo que sin lock.						//===========Termina código compartido						kdb.iov("PUT,"&archFoliador&",1");//Resetea el foliador para liberar el recurso compartido					}else{						//Si no se pudo obtener el recurso compartido, se espera un momento (300 milisegundos) para no acaparar demasiados recursos del servidor. 						sys.delay("300");					}				}			}			fun ObtenUltimo(){				kdb.rst("datArch");				kdb.file("datArch,read,"&arch);				kdb.exec();				return kdb.get("datArch","r0");			}						fun Guarda(val){				var xml;rstXml(xml);				setXml(xml,"r0",val);				kdb.file("datArch,write,"&arch&",EOL:13_10",xml);			}		}	</script></pag>